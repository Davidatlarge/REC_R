---
title: "REC_R"
<<<<<<< HEAD
output: github_document
=======
output: html_document
>>>>>>> REC_R_v1-2-3/master
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
<<<<<<< HEAD
=======
sapply(list.files("user_functions/", pattern = ".R$", full.names = TRUE), source)
>>>>>>> REC_R_v1-2-3/master
```

This project attempts to translate algorithms implemented by **Rate Estimation from Concentration (REC)** in matlab code into R code. Some minor changes to the workflow are also intended.

REC was originally developed by Karsten Lettmann ([Lettmann et al. 2012](https://www.sciencedirect.com/science/article/abs/pii/S0272771411000229)) and can be downloaded [here](https://uol.de/icbm/physikalische-ozeanographie-theorie/downloads).


<<<<<<< HEAD
## Working concept
The main function, the one that eventually should be used by the user, is now worked on in a file called `REC_R.R`. It takes as inputs the input data (now stored in several files but eventually supplied from R objects) and a bunch of arguments including boundary conditions and parameters for the calculation.

The main function itself only does minor pre-processing of the input variables and passes the results to other functions. These functions are currently already defined as R functions.

Eventually, the aim is to provide input to the main function and get all the output that REC originally creates in one go, probably as a list.

At the moment providing the inputs, pre-processing and calling the function `calculate_con_rates_lin_sys_tichonov_mean_rate_2` does produce a result, but it is obviously wrong.


## What was done so far
- functions, `if` clause and `for` loops were translated from Matlab to R syntax  
- where the matlab function defined more than 1 element, the corresponding R function defines a list containing these elements  
- `pracma::` and `matlab::` packages were used to call matlab style functions in many cases  
- all functions contained in any script were placed in their own r file  


## Find out...
- what is the result of `Estimating the best alpha Parameter` in `calculate_con_rates_lin_sys_tichonov_mean_rate_2`?  
- Why does `[x_min, ind] = min(x_min_vec)` in `find_local_minimum_with_smallest_x()` get "overwritten" by the following line?  
- is `C_hat` in `calculate_con_rates_lin_sys_tichonov_mean_rate_2()` supposed to be a [N,N] matrix (as now) or a [N,1] matrix?  


## TODO
- check where matrix multiplication is needed  
- use `matlab::` or `pracma::` whereever possible   
- change definition of an object `F` because it could be mistaken for `FALSE`  
- generally make nicer names for objects 
- `E` in `find mean rates` seems obsolete  
- change `print()` to `cat()`  
- unify use of `"` vs `'`  
- unify use of 'Tikhonov' and 'Tichonov' (only in commented text)


## Planned functional changes 
- remove the need for `read_bnd_cond_structure()` since it is anyways only a renaming, e.g. in   `calculate_diff_operator_matrix_aequi_dist_grid_variable_coeff()`.  
- calculate the fluxes in the main fun, now they are calculated only when written to file by `write_fluxes()`, or make the output so that the fluxes can be calculated by another fun from the output.  
- calculate integrated fluxes in the main fun, now they are calculated only when written to file by `integrate_rates()`, or make the output so that the fluxes can be calculated by another fun from the output.  
- but a name should be definable somewhere   
- make the result a list of result objects rather than writing them to file directly  
- make graphic output optional (if slow)  
- make graphic output a base plot with fixed dims
- bring back the figure printing? 
- include in results a report in text giving a step by step of the calculation and saying which parameters and conditions were used 


## Implemented functional changes
- replace data reading via files with direct data vector supply to function  
- does `diff_op` in `calculate_diff_operator_matrix_aequi_dist_grid_variable_coeff()` have to be a [N,N] matrix or should it be a [N,1] matrix? it creates many following matrices that want to be [N,1] but because of calculations with `diff_op` must become [N,N]. -- yes, but the initial multiplication with d was wrong, d had to be transposed from [1,N] into a [N,1] matrix rather than forced into a [N,N] matrix  



## Trouble shooting ideas
- try transposing the 1 col matrices that were multiplied, added to square matrices by changing `by.rows` argument.  
- change matrix multiplication to "simple" multiplication  

- calculations inside `abl_1()` should be correct because they are easy to understand and only single values are ever multiplied or added and hence matrix calculation play no role  

- gone thru `find_mean_rate`, should be ok  
- gone thru `calculate_con_rates_lin_sys_tichonov_mean_rate_2`, should be ok  

## a note on data input files
The function `read_input_data_func()` just reads in the data one by one, extracting from the concentration file the concentration and depth vectors, interpolating data to fit the number of grid points supplied in the top function.
For each parameter read from file it does the same interpolation (extension to the required grid number) by using the user defined function `operate_property()`.  
**THE FUN IS OBSOLETE IF THE INPUT DATA IS DIRECTLY SUPPLIED AND INTERPOLATED IN THE TOP FUN**  

input files:  
- z - depth  
- C - concentration  
- phi - porosity  
- omega - vertical advection velocity  
- D - effective molecular diffusion coefficient D  
- Db - bioturabtion coefficient DB  
- beta - irrigation coefficient   
output objects:  
- z_data  
- C_data  
- z_c  
- C_c  
- omega  
- D_total  
- beta  
- phi  
- error  

```{r eval=FALSE}
read_input_data_func <- function(
  path_to_input_files # redundant is working with df from environment  
  N_c # Number of computational grid points ALSO IN MAIN FUN
  # objects created by reading the files:
  z_data,
  C_data,
  z_c,
  C_c,
  omega,
  D_total,
  beta,
  phi,
  error
){
  
  # ------ read concentrations AND DEPTH FROM THE CONCENTRATOIN FILE----------------
  z_c = matlab::linspace(z_data[1], z_data[length(z_data)], N_c) # 
  
  C_c = interp1(z_data, C_data, xi = z_c, method = "linear") # interp1() is the same in r and matlab
  
  # ---------- porosity ---------------------
  
}
```
=======
## Preparing data
The matlab version requires data input from a 'setup', a folder containing individual data files named \*_C.txt, \*_phi.txt, \*_omega.txt , \*_beta.txt, \*_D.txt, and \*_Db.txt, all files contain z (depth) values. This R version take as input a data frame with columns `c(z, C, phi, omega, beta, D, Db)`. Setups can still be used and data imported from them using the function `import_from_setup()`. `import_from_setup()` takes as argument the path to a setup folder, finds the required files in the setup folder and merges them based on z (depth) values, but ignores all other files so that results (or other) files could be saved in the setup without interfering with the import. Columns z, C, phi and D have to be supplied and cannot be all zeros; columns omega, beta, and Db may not be supplied and will the be substituted with all zeros.
*C* denotes concentration of the water constituent. $\phi$ (phi) denotes the sediment porosity, $\omega$ (omega) the sedimentation rate combined with pore water advection, *D* the molecular diffusion coefficient (corrected for sediment properties), *D~B~* (Db) denotes the bioturbation coefficient, $\beta$ (beta) the coefficient of irrigation.

Here we import data from the original example setup.

```{r}
df <- import_from_setup("test_case_2_data_delta/")
head(df)
```

## Running the main function
The example data is passed to the main function `rec()` as data frame. `rec()` takes a number of arguments to guide the modeling of the concentration profile and rates at a supplied depth resolution. The function then interpolates input data to the required resolution, passes them together with input arguments to a calculation function `calculate_con_rates_lin_sys_Tikhonov_mean_rate_2()`, and compiles the results for output as a names list. Internally, `calculate_con_rates_lin_sys_Tikhonov_mean_rate_2()` calls a few other functions.

```{r}
test <- rec(original_data = df,
            N_c = 101,               # Number of computational grid points
            C_water = 25e3,          # Nutrient concentration in water column (only important for irrigation)
            # parameters for Tikhonov regularization
            lambda = 1,              # 'smoothing' parameter lambda
            alpha_min = 8,           # lowest alpha value for Tikhonov regularisation and ratio criterion ( actually log_10(alpha_min) )
            alpha_max = 15,          # largest alpha value for Tikhonov regularisation and ratio criterion ( actually log_10(alpha_max) )
            N_alpha = 301,           # Number of ratio criterion evaluations in the alpha interval, to find the minimum
            # setting the boundary conditions for the nutrient concentration
            bnd_cond_type_z_min = 1, # type of boundary condition at the top: 1: for concentration / 2: for derivative
            bnd_cond_C_z_min = 25e3, # value of nutrient concentration or derivative at top
            bnd_cond_type_z_max = 1, # type of boundary condition at the bottom: 1: for concentration / 2: for derivative
            bnd_cond_C_z_max = 5e3   # value of nutrient concentration or derivative at bottom
            )
```

```{r}
summary(test)
```
The list contains the *input data* as a data frame; the *input parameters* entered as arguments of `rec()` as a list; the interpolated data (i.e., the input data at a depth resolution passed to  `rec()` via `N_c`, minus the z column) as a data frame; the output data of z in the required resolution and the corresponding *interpolated concentrations* and *calculated rates* as a data frame; the *optimum alpha* value; a vector of all tested alpha values and a vector of corresponding Tikhonov criterion values.

## Visualize results
The function `plot_rec()` makes it easy to plot results for a quick overview. It works on the output from `rec()`, so all plots (and more) can also be produced directly from the output.

By default `plot_rec()` plots a two panel depth profile of input and interpolated concentrations and calculated rates. The argument `type` can be used to produce figures of the input data or of the Tikhonov criterion as a function of alpha. The latter is useful to check if a local minimum in the Tikhonov criterion was actually found and a corresponding optimal alpha value used. This optimal alpha is shown on the figure as a green dot. Printed output from `rec()` will also warn if no local minimum was found and the absolute minimum is used as the location of the optimal alpha.

```{r}
plot_rec(test)
plot_rec(test, type = "localmin")
plot_rec(test, type = "input")
```

## Calculate boundary fluxes
Fluxes of the constituent of "C" across the upper and lower boundary of the depth profile can be calculated with `boundary_fluxes()`. This is useful e.g. in studies of benthic-pelagic coupling. The function accepts the output of `rec()`. By default, an explanation of the calculation is printed to the console, this can be suppressed by setting the argument `explain = FALSE`.

```{r}
boundary_fluxes(test)
```

## Calculate integrated rates
The rates of production of a constituent for "C" can be integrated using `integrate_rates()`. The integration interval can be defined using the `z_min` and `z_max` arguments but if no values for these are supplied, rates will be integrated over the entire z range. By default, the calculation will be explaind as text printed to the console but this can be suppresed by setting the argument `explain = FALSE`.

```{r echo=FALSE}
plot(test$output_data$z~test$output_data$rate, 
     ylim = rev(range(test$output_data$z)), ylab = "z", xlab = "rate", type = "l", col = "red")
abline(h = c(0,30), col = "blue")
```

```{r}
integrate_rates(test)
integrate_rates(test, z_min = 0, z_max = 30, explain = FALSE)
```



>>>>>>> REC_R_v1-2-3/master

